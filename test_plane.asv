

clear;
 clc;
all_data = importdata('data/test_plane.csv');

pose_data = importdata('data/test_plane_pose.csv');

% 初始化变换矩阵X
X = eye(4);

% 提取位移向量和四元数
translation = pose_data(1:3);
quaternion = [pose_data(7), pose_data(4:6)];

% 将四元数转换为旋转矩阵
rotation_matrix = quat2rotm(quaternion);

% 构建变换矩阵X
X(1:3, 1:3) = rotation_matrix;
X(1:3, 4) = translation;

% 打印变换矩阵X
disp('变换矩阵X:');
disp(X);


data = all_data;

[numRows, numCols] = size(data);
M = [];
inv_A = [];
for i=1:numRows
    M = [M; data2plane(data(i, 1:3))];
    data2trans(data(i, 4:10));
    inv_A = cat(3, inv_A,data2trans(data(i, 4:10)));
end


data_sta = 1;
data_end = numRows;

Y = [];
for i = 1:length(inv_A)
    Y = [Y; M(i,:) * X * inv(inv_A(:,:,i))];
end

Y

real_Y = mean(Y);
real_Y(1:3) = real_Y(1:3) / norm(real_Y(1:3));
S_y = std(Y);  %计算标准差,除以的是（N-1）


all_former_result;
N = size(all_former_result, 1);
S_all_former_result = std(all_former_result);

S_all_former_result = sqrt(S_all_former_result.^2* (N-1) / N) * 1000  %单位mm
error_former_t = sqrt(sum(S_all_former_result(1:3).^2))
Q = all_former_result(:,4:7);
Q_avg = avg_quaternion_markley(Q)';
T = all_former_result(:,1:3);
T_avg = mean(T);

error_qi = zeros(size(Q, 1), 1);
for i = 1:size(Q, 1)
    error_qi(i) = quaternionDifferenceAngle(Q(i, :), Q_avg) * 180 / pi;
end
error_former_q = mean(error_qi);        %绝对值的均值，单位为°
error_former_R = sqrt(sum(error_qi.^2)/size(Q, 1))     %平方和均值，单位为°





all_result;
N = size(all_result, 1);
S_all_result = std(all_result);

S_all_result = sqrt(S_all_result.^2* (N-1) / N) * 1000  %单位mm
error_t = sqrt(sum(S_all_result(1:3).^2))
Q = all_result(:,4:7);
Q_avg = avg_quaternion_markley(Q)';
T = all_result(:,1:3);
T_avg = mean(T);

error_qi = zeros(size(Q, 1), 1);
for i = 1:size(Q, 1)
    error_qi(i) = quaternionDifferenceAngle(Q(i, :), Q_avg) * 180 / pi;
end
error_q = mean(error_qi);        %绝对值的均值，单位为°
error_R = sqrt(sum(error_qi.^2)/size(Q, 1))     %平方和均值，单位为°
